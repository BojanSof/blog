---
title: Rise of the Homelab
date: 2025-06-20
categories: [Networking, Homelab]
tags: [networking, homelab, vm, containers, docker, proxmox]
math: false
image:
  path: /assets/img/homelab/cover.webp
---

A homelab is a personal IT environment used for learning, experimenting, and self-hosting services.
For me, it was a great way to learn about networking, security, self-hosting applications, and managing an environment end-to-end.
In this post I describe my homelab, how I built it, and some of the challenges I encountered during development.
It's fairly simple right now, but it can provide useful insights to anyone wanting to start one.

## Brief history of my homelab

Earlier this year, I moved to a new apartment.
While I was packing boxes with stuff from the old apartment, I found an old [FritzBox](https://fritz.com/en) all-in-one router and DSL modem in one of the storage shelves.
The specific model was [FritzBox 7360SL](https://boxmatrix.info/wiki/FRITZ!Box_Fon_WLAN_7360_SL).
To me such boxes are fascinating because they are essentially embedded Linux machines with the potential to do many tasks besides their main purpose.
How cool it is to have VPN server to your home network running on the router itself!
Or blocking ads for the whole network!

I had experience modding other FritzBox devices — around a year and a half ago I tried to mod another FritzBox to run [Freetz](https://freetz.github.io/) (the maintained fork is [Freetz-NG](https://freetz-ng.github.io/freetz-ng/)). Freetz provides firmware modifications that allow running custom packages such as VPN servers, HTTP servers, custom DNS, and more.
Also, there's a whole wiki for FritzBox devices: [BoxMatrix](https://boxmatrix.info/wiki/BoxMatrix), which contains a lot of technical details for many different models.
I was fortunate to collaborate with the BoxMatrix maintainer, hippie2000, to get Freetz running on my FritzBox; I learned a lot from him about modifying and adapting Linux configurations and modules.
Kudos to him!
I used this FritzBox device to run OpenVPN server to access the home network, and I was running [dnsmasq](https://en.wikipedia.org/wiki/Dnsmasq) with [Addhole](https://freetz-ng.github.io/freetz-ng/make/addhole/?h=addhole) extension, to block list of hostnames that contain ads, malwares, trackers and other unwanted things.
It also helped me learn about terms like [Dynamic DNS](https://en.wikipedia.org/wiki/Dynamic_DNS) and [DMZ](https://en.wikipedia.org/wiki/DMZ_(computing)), and see how to practically use them.
But it wasn't the smoothest experience, as the hardware was a bit outdated and didn't have a lot of power.

When I was packing the FritzBox 7360SL, I did a quick Google search and noticed that [OpenWRT](https://openwrt.org/) supports this device.
I've always wanted to try OpenWRT — Linux targeting embedded devices, mainly for networking tasks.
It's a great way to keep old equipment (no longer supported by the manufacturer) running with a recent Linux kernel, security patches, and bug fixes.
OpenWRT also has a very large and comprehensive package repository.

After moving to the new apartment I had some time to experiment with the FritzBox 7360SL.
I installed OpenWRT on it following the [OpenWRT guide](https://openwrt.org/toh/avm/fritz.box.wlan.7360) and was amazed at how many configurations and customizations were available in the Web UI — it made the hardware feel very powerful.
Creating network interfaces, creating VLANs, managing firewall zones, looking at the enormous OpenWRT package list were things that opened the doors to many new learning opportunities.

Quickly after that, I got introduced to [Proxmox](https://pve.proxmox.com/wiki/Main_Page) - server virtualization management solution based on QEMU/KVM and LXC (Linux Containers).
I bought myself cheap refurbished HP260 G2 mini PC, with i3-6100U 2-core/4-thread CPU, 8 GB RAM and 256 GB SSD.
It has a very small form-factor, making it easy to put it under table or in a corner.
I've installed Proxmox on it and started spinning out VMs and LXCs - Adguard Home for DNS, InfluxDB and Grafana for monitoring the PC, Nginx Reverse Proxy, host my WebRTC chat application, self-host Music library, and many more.

My latest update to the homelab equipment was a [GL.iNet Flint 2](https://www.gl-inet.com/products/gl-mt6000/), a high-performance router I got as a birthday gift.
The Flint 2 is considered one of the best OpenWRT routers by many users — it has a very powerful CPU (MediaTek Filogic 830, MT7986AV), 1 GB RAM, 8 GB eMMC, two 2.5 Gbit ports, four 1 Gbit ports, and a USB 3.1 port.
It upgraded the FritzBox 7360SL device, which was behaving weirdly sometimes - WiFi was disconnecting and it was becoming unresponsive.
Now, the whole network feels much smoother.

## Diagram

![Homelab diagram](/assets/img/homelab/homelab.svg){: .light}
![Homelab diagram](/assets/img/homelab/homelab-dark.svg){: .dark}
_Diagram of my current homelab_

The homelab is pretty simple.
The Flint 2 is connected to the ISP gateway.
The ISP gateway is NOT configured in bridge mode, as I need to contact the ISP to configure the gateway in bridge mode.
The HP 260 G2 is the server running Proxmox and all containers and VMs.
Before I had the Flint 2, the FritzBox 7360SL was doing its job.

> One thing that I found useful with the FritzBox 7360SL, which has small amount of internal Flash memory, is to use small external USB drive to extend the root file system, to have storage for installing packages. OpenWRT wiki has [tutorial](https://openwrt.org/docs/guide-user/additional-software/extroot_configuration) how to achieve this.
{: .prompt-info }

### Router config

The Flint 2 router by default runs GL.iNet firmware, which is a fork of the official OpenWRT project, aiming to provide ease of use by limiting some of the features that stock OpenWRT provides.
Also the manufacturer can delay or stop delivering updates and features, while OpenWRT will be updated and maintained beyond that moment.
For these reasons, I've installed stock OpenWRT on the Flint 2, following the [OpenWRT wiki](https://openwrt.org/toh/gl.inet/gl-mt6000), which is a very easy process, as the original firmware is OpenWRT basically.

#### LuCI theme

After installing the stock OpenWRT, I changed the OpenWRT web interface (LuCI) theme.
OpenWRT wiki has overview for [LuCI themes](https://openwrt.org/docs/guide-user/luci/luci.themes).
The theme that I like to use is called [Argon](https://github.com/jerrykuku/luci-theme-argon).
This theme provides both dark and light modes, and one can customize the accent colors, the login background and few more options.
The [theme's github repo](https://github.com/jerrykuku/luci-theme-argon) provides instructions how to install the theme.

![LuCI with Argon theme](/assets/img/homelab/luci-argon.png)
_LuCI (OpenWRT web interface) with Argon theme_

#### Wake-on-LAN (WoL)

Occasionally there are power outages.
After power is restored the router typically powers on automatically, but the computers usually do not.
That means services hosted on those machines won't be available until the machines are powered on.

To resolve this issue, the computer network interface card (NIC) can listen to incoming network traffic even when the computer is OFF.
When a specific frame called a "magic packet" containing the NIC's MAC address is sent on the network, the NIC can power on the computer — the same effect as pressing the power button.
This feature is called [Wake-on-LAN (WoL)](https://en.wikipedia.org/wiki/Wake-on-LAN).

We can make the router send magic packet to a computer, to power it on.
To make WoL work properly, we need to configure both the router and the computer that needs to be woken.
In this section, we will only configure the router, while the computer part will be presented later.

OpenWRT wiki has [page](https://openwrt.org/docs/guide-user/services/w_o_l/wol) for configuring WoL.
On the Flint 2, to use the WoL feature we need to install package called `etherwake`, which is a command-line utility that can generate and send magic packet.
Besides `etherwake`, there is also a package called `luci-app-wol`, which adds an option to use the WoL feature via the router web interface under `Services -> Wake on LAN`.
`luci-app-wol` installs `etherwake` as a dependency.
Installing packages on OpenWRT is quite easy and can be done via LuCI, by going to `System -> Software`, then `Update lists...` to update the packages list and search and install the `luci-app-wol` package.
The installation can also be done via command line after connecting to the router via SSH, by issuing `opkg update && opkg install luci-app-wol`.

If we want to wake computer or any device that supports WoL automatically when the router boots, we can add `etherwake` command in `/etc/rc.local`:
```
# wake the computer with MAC aa:bb:cc:dd:ee:ff, connected on `br-lan` network interface
etherwake -i br-lan -b aa:bb:cc:dd:ee:ff

exit 0
```
{: file='/etc/rc.local'}

#### WireGuard VPN server

Often, we require access to our homelab network from outside.
To achieve this, we can use [VPN](https://en.wikipedia.org/wiki/Virtual_private_network).
In my scenario, I run WireGuard VPN server on the Flint 2 and use WireGuard client on my laptop and phone to access the homelab network when needed.

Before configuring the WireGuard server, we need to know the public IP address for our network.
There are multiple options for the public IP address:
1. The user has a static IP, i.e. the address `92.56.292.123` always belongs to the user and never changes. This is the simplest scenario, but often ISPs require users to pay extra for this.
2. The user has dynamic IP address, which means his IP may change depending on some policy, i.e. after few hours or days. In this scenario the user can use [Dynamic DNS (DynDNS)](https://en.wikipedia.org/wiki/Dynamic_DNS) service, which basically updates given domain DNS record whenever the IP changes. There are many free DynDNS services that can be used. I use [`No-IP`](https://www.noip.com/), which provide DynDNS service for free, for single domain. After registering for DynDNS service, one needs to enter the domain and the security info for the domain on the router. Currently, I do that on the ISP gateway.
3. It is possible that the user's public IP address is shared with multiple other users through [CGNAT](https://en.wikipedia.org/wiki/Carrier-grade_NAT). This is the trickiest scenario and can complicate remote access; solutions depend on your ISP and setup.

The OpenWRT wiki has [tutorial](https://openwrt.org/docs/guide-user/services/vpn/wireguard/server) for configuring WireGuard VPN server, both via command-line and via LuCI.
The process is straight forward:
1. Install the required package, `luci-proto-wireguard` should install everything that is required
2. Create new network interface with the `WireGuard VPN` protocol, named `wg0` for example
3. Press on the `Edit` button for the network interface and in the `General` tab press on `Generate new key pair` to generate the server public and private keys.
4. Enter the IP address for the VPN and the UDP listen port.
5. Ensure to assign firewall zone for this network interface. It can be the `lan` zone, used for the other devices that are part of the network.
6. Save all the changes.

After the server is configured, we can add peers, which is quite simple using the web interface:
1. Press on `Edit` on the WireGuard network interface, then go to the `Peers` tab.
2. Press on `Add peer` button
3. Generate the public/private key combo for the client
4. Add IPv4 address in the `Allowed IPs` field, on the same subnet as the one specified during server configuration.
5. Set the `Endpoint host` to the domain where your static IP is bound, or the DDNS domain.
6. Set `Persistent Keep Alive` to 25.
7. Save the peer configuration.
7. Then go and press `Edit` again and click on the `Generate Configuration...` button, to generate the config for the WireGuard client.

Sample WireGuard client config should look like this:
```
[Interface]
PrivateKey = GEKQHqEBBnCJXsFDVwKSZCy9VxV/OEBVUkLlISxBvVM=
Address = 10.10.0.10/32
DNS = 192.168.1.1

[Peer]
PublicKey = EjmgJpwmXgOWyaj3+ndUbbtRKs7FCn86xKpifzKOZj4=
PresharedKey = G3j9waP+Er04RVlSSk5MJgyNIwEW6z+Qybku8x4+eak=
AllowedIPs = 0.0.0.0/0, ::/0
Endpoint = example.domain.net:51820
PersistentKeepalive = 25
```
{: file='wg-client.conf'}

WireGuard provides [client softwares](https://www.wireguard.com/install/) for many operating systems.
Install and apply the peer configuration that we generated.
For easy testing on PC/Laptop for example, enable hotspot on your mobile phone to share the mobile data, connect to the hotspot, activate the WireGuard tunnel and check if you can access the homelab network.

Finally, we need to configure the firewall to forward the WireGuard port.
This can be done via LuCI, by going to `Network -> Firewall` then `Port Forwards`.
Add new port forwarding rule, set the source to the WAN interface, external port to the WireGuard port, i.e. 51820 by default, set the destination zone to the WireGuard interface assigned firewall zone and set the internal port, often same as the external one.

With this, we can easily access our homelab network from anywhere!

> If you have another router in front of the one running the WireGuard server, you also need to do the port forwarding configuration on it. Another alternative is to enable [DMZ host (demilitarized zone)](https://en.wikipedia.org/wiki/DMZ_(computing)#DMZ_host) feature on the front router, which makes its firewall expose all ports to the DMZ host, which in our case is the router running WireGuard server.
{: .prompt-info }

### Proxmox server

![Proxmox web interface](/assets/img/homelab/proxmox.png)
_Proxmox web interface_

When I started playing with firmware extensions and modifications for routers that had little flash and RAM, it felt powerful to run additional software on them (for example, custom DNS and ad blocking).
However, I quickly realized the limits of such devices.
Around that time I discovered Proxmox, an open-source virtualization platform that allows self-hosting a variety of applications.
So I bought a refurbished HP 260 G2 mini PC for this purpose.
It has an Intel i3-6100U CPU (2 cores/4 threads), 8 GB of RAM, and a 256 GB SSD.
I also had a 512 GB NVMe SSD in an external USB enclosure connected to the PC for extra storage.

Installing Proxmox is quite easy and similar to installing any other OS.
Proxmox also has wiki pages, which have a ton of technical details and tutorials, including [installation](https://pve.proxmox.com/wiki/Installation) page.
But there are also a ton of online resources in case one gets stuck on something.
Before installing Proxmox, ensure virtualization is enabled in the PC BIOS/UEFI (often called `Virtualization Technology`).

After installing Proxmox, it provides a web interface accessible at the IP assigned to the host.

#### Enabling WoL

Before carrying on with spinning up containers and VMs, let's enable Wake-on-LAN on the Proxmox server, so the router can power it on using a magic packet.

1. Enable the WoL feature in the BIOS/UEFI
2. Boot the PC and open the Proxmox shell
3. Install the `ethtool` package: `apt install ethtool`
4. Edit the `/etc/network/interfaces` file, and under the ethernet interface used for connecting to the router add the line `post-up /usr/sbin/ethtool -s enp1s0 wol g`, which enables the WoL on magic packet after the network interfaces comes up:

```
auto lo
iface lo inet loopback

iface enp1s0 inet manual
post-up /usr/sbin/ethtool -s enp1s0 wol g

auto vmbr0
iface vmbr0 inet static
        address 192.168.1.2/24
        gateway 192.168.1.1
        bridge-ports enp1s0
        bridge-stp off
        bridge-fd 0

source /etc/network/interfaces.d/*
```
{: file='/etc/network/interfaces'}

#### Proxmox VE Helper-Scripts

Before going over some of the self-hosted applications I have, I wanted to mention one great community project, called [Proxmox VE Helper-Scripts](https://community-scripts.github.io/ProxmoxVE/).
The goal of this community project is to provide scripts to simplify the setup and management of services on the Proxmox server.
It provides great collection of scripts that one can use to install many different applications, including network-related services, web servers, media hosting solutions and many more.
Before trying to install something manually, by spinning VM or LXC, be sure to check the helper scripts, they can save a lot of time!

#### AdGuard Home

![AdGuard Home Dashboard](/assets/img/homelab/adguard-home.png)
_AdGuard Home Dashboard_

One of the most common services in a homelab is an ad blocker.
The solution I opted for was to use [AdGuard Home](https://github.com/AdguardTeam/AdGuardHome), which is free, open-source, network-wide ads tracker and blocker DNS server.
I installed it using [helper script](https://community-scripts.github.io/ProxmoxVE/scripts?id=adguard), which creates LXC for it.

Basically, AdGuard Home is DNS server, which provides option to add blocklists of hosts, which won't be allowed on the network.
First, configure the upstream DNS servers by going to `Settings -> DNS settings` and entering the IP addresses of the chosen DNS servers in the `Upstream DNS servers` textbox.
There are few popular options for it that I want to mention:
- Google Public DNS: 8.8.8.8 and 8.8.4.4, which provides fast performance and very good reliability.
- Cloudflare DNS: 1.1.1.1 and 1.0.0.1, focusing on privacy.
- Quad9  DNS: 9.9.9.9, focusing on security by blocking malicious websites, ensuring safer browsing.

Additionally, if you want to ensure that only devices on your network can use AdGuard Home DNS, you can go to `Settings -> DNS settings`, and under the `Access settings` pane, enter the CIDRs in the `Allowed clients` text box.

![AdGuard Home DNS configuration](/assets/img/homelab/adguard-home-dns-cfg.png)
_AdGuard Home DNS configuration_

AdGuard Home provides quite few blocklists which one can select from.
Personally, I use [HaGeZi Pro](https://github.com/hagezi/dns-blocklists?tab=readme-ov-file#pro) and [HaGeZi TIF](https://github.com/hagezi/dns-blocklists?tab=readme-ov-file#tif) blocklists.
Another good source for blocklists that is worth mentioning is [firebog.net](https://firebog.net/).

After configuring AdGuard Home, we can change the DHCP server settings on our router to provide the AdGuard Home IP address as the DNS server, or we can configure the DNS server IP on each client separately (required if a client uses a static IP).

#### Nginx Proxy Manager

![Nginx Proxy Manager](/assets/img/homelab/nginx-proxy-manager.png)
_Nginx Proxy Manager Proxy Hosts page_

Before adding more applications and services to our homelab, there is one potential problem that would arise - remembering the IP addresses and ports of each application.
If there are 2-3 applications we may be able to remember their IPs and ports, to access their web interfaces, but then we start to forget and mix them.
We can always check their IPs in proxmox, but we can create a better solution using [Nginx Proxy Manager](https://nginxproxymanager.com/).

Nginx Proxy Manager is an open-source tool that provides user-friendly web interface for configuring reverse proxies, without needing to write configuration files for [Nginx](https://nginx.org/).
Basically, its purpose is to forward domain requests (i.e. example.com) to correct internal server (i.e. server that has IP `192.168.1.45:4000`).
Instead of remembering IP addresses for our applications and services, we can use domains, like `adguardhome.local`.
The more complicated explanation for what Nginx Proxy Manager does is that it utilizes Nginx as reverse proxy, easy and automated SSL certificates from [Let's Encrypt](https://letsencrypt.org/) and provides simple, user-friendly web interface.

We can install it in LXC, using [helper script](https://community-scripts.github.io/ProxmoxVE/scripts?id=nginxproxymanager).
After installing Nginx Proxy Manager, we need to tell the manager how to redirect the domains, to which IP addresses.
We can simply do this by going to `Hosts -> Proxy Hosts` page.

![Adding proxy host in Nginx Proxy Manager](/assets/img/homelab/nginx-add-host.png){: w="400"}
_Adding proxy host in Nginx Proxy Manager for AdGuard Home_

Finally, we need to tell our DNS server to redirect the requests for the `.local` domains to the Nginx Proxy Manager instance.
In Adguard Home, we can do this by going to `Filters -> Custom filtering rules` page and add the rules in format `<Nginx Proxy Manager IP> example.local`, i.e. if the Nginx Proxy Manager IP is `192.168.1.4`, we can add the following rule `192.168.1.4 adguardhome.local`.

As a bonus, Nginx Proxy Manager doesn't have dark mode support, but we can easily add one following the [GitHub issue](https://github.com/NginxProxyManager/nginx-proxy-manager/issues/707) related to this topic.
Basically, we add proxy host for Nginx itself, let's say `nginx.local`, and under `Custom Locations` we add the following settings, copied from the GitHub issue:
```
proxy_set_header Accept-Encoding "";
sub_filter
   '</head>'
   '<link rel="stylesheet" type="text/css" href="https://theme-park.dev/css/base/nginx-proxy-manager/organizr.css">
   </head>';
sub_filter_once on;
```
{: file='nginx_theme'}

![Nginx Proxy Manager dark mode](/assets/img/homelab/nginx-dark-mode.png)
_Adding theme support for Nginx Proxy Manager_

#### Open Media Vault

![Open Media Vault dashboard](/assets/img/homelab/omv.png)
_Open Media Vault dashboard_

I had one 512 GB NVMe SSD lying around, so I decided to use it for media storage.
I bought a USB M.2 NVMe SSD enclosure and connected the drive to the Proxmox host.
Initially I mounted the SSD on the Proxmox host and used [Network File System](https://docs.kernel.org/filesystems/nfs/index.html) (NFS) to share the drive with the VM running the music library.
The Proxmox host ran the NFS server while the VM was the NFS client.
Shortly after, I also wanted a Samba server to access miscellaneous files on the network — which made Proxmox responsible for disk and share management.
At that point I realized a conceptual mistake: Proxmox should not be managing the storage directly; it should only manage LXCs and VMs.

While searching for solutions to manage storage, I stumbled upon [Open Media Vault (OMV)](https://www.openmediavault.org/), which is NAS solution based on Debian, containing a lot of services, like SMB, NFS and FTP.
It seemed like a perfect solution to manage the drive, so I started migrating my old solution, in which proxmox was managing the drive, to the new solution, on which OMV will manage the drive and create all the required shares.

I installed OMV inside a VM and passed the external drive through to that VM following the Proxmox [wiki tutorial](https://pve.proxmox.com/wiki/Passthrough_Physical_Disk_to_Virtual_Machine_(VM)):
```
# First find the UUID of the drive
lsblk -o PATH,TYPE,MOUNTPOINT,UUID
# Passthrough the drive
qm set <OMV_VM_ID> -scsi1 /dev/disk/by-uuid/<DISK-UUID>
```
{: file='vm_drive_passthrough'}

Now, we can configure OMV to manage the drive.
Because I had an existing filesystem on the drive, I mounted it via `Storage -> File Systems` and pressed `Mount an existing file system` to select the external drive.

After the filesystem is configured, we can start utilizing services, like NFS and SMB to share the drive.
Before doing so, OMV requires us to create a [shared folder](https://docs.openmediavault.org/en/latest/administration/storage/sharedfolders.html) under `Storage -> Shared Folders`.
For each shared folder, we specify the file system that we want to use and the relative path from the root.
Remember that each service you plan to use must be bound to a single shared folder.
In my case, I have share folder for the media library (which currently consists only of music), share folder for Samba, and I have one share folder for the whole external drive (which may not be a good practice), which is used for the NFS share on the proxmox server itself, to provide access to the external drive to LXCs that need it.

One thing that I won't cover here is permissions of the folders and how to handle them in best manner.
Instead, what I did is I owned the whole external drive partition by the OMV VM, by running `chmod -R 777 /srv/dev-disk-by-uuid-XXXX`, then for the NFS shares for the music VM, I've added options `all_squash, anongid=1000, anonuid=1000`, which means every request, from no matter which user on the NFS client, treat is as it comes from the anonymous user, and use UID and GID of 1000.

As I mentioned, one of the NFS shares is used to provide access to the external drive for LXCs.
To make this work the Proxmox host acts as an NFS client and mounts the share by adding the following line to `/etc/fstab`:
```
# ...
# OTHER CONTENT of the file
# ...
192.168.142.14:/storage /mnt/storage nfs defaults,_netdev,nofail,x-systemd.automount,x-systemd.mount-timeout=30 0 0
```
{: file='/etc/fstab'}

Note the mount options: `_netdev,nofail,x-systemd.automount,x-systemd.mount-timeout=30`. They indicate that the mount is a network device (`_netdev`), should not cause boot failure if it is unavailable (`nofail`), and instruct `systemd` to automount the share when it is first accessed (with a timeout set by `x-systemd.mount-timeout`).

Briefly, to use Samba, which enables file sharing across different operating systems over a network, first we need to create users in OMV and then create SMB share.
Then we can access the Samba share on other system on the network using the credentials of the user we created.

#### Self-hosted Music Library

One of the best things to do in a homelab is self-host media services — music, movies, TV series, books, etc.
There is a set of tools (the "*Arrs") that can automatically download and organize media collections. The most commonly used are:
- [Lidarr](https://lidarr.audio/) — music collection manager
- [Sonarr](https://sonarr.tv/) — TV series collection manager
- [Radarr](https://radarr.video/) — movies collection manager
- [Prowlarr](https://prowlarr.com/) — indexer manager for the other *Arrs

I use `Lidarr` to manage the music library. For indexers and downloading, I use `Prowlarr`, and to integrate with Soulseek I use [`Soularr`](https://soularr.net/) together with the [`slskd`](https://github.com/slskd/slskd) client.
`Soulseek` is a peer-to-peer file-sharing application popular among music collectors. Unlike torrents, Soulseek often uses a single direct connection to a seeder.
For torrents I use [`qBittorrent`](https://www.qbittorrent.org/). For streaming and the web UI I use [`Navidrome`](https://www.navidrome.org/), which also supports the Subsonic API and is compatible with many mobile apps.

On Android I personally like the paid app [`Symfonium`](https://symfonium.app/) for its design and Chromecast support, though free alternatives exist (for example, `substreamer`).

The components I run for the music library are: `Lidarr`, `Prowlarr`, `Soularr`, `slskd`, `Navidrome`, and `qBittorrent`.
I deploy most services in a VM, and run `qBittorrent` as an LXC so it can be reused for other purposes.

Creating the `qBittorrent` LXC is straightforward using the [helper script](https://community-scripts.github.io/ProxmoxVE/scripts?id=qbittorrent).
After creating the LXC you need to mount the external drive in the container. The easiest way is to edit `/etc/pve/lxc/<LXC_ID>.conf` and add a mount point. For example:

```
mp0: /mnt/storage/torrents,mp=/torrents
```

To host the other apps, I created a VM with [Debian 13](https://www.debian.org/News/2025/20250809) (no desktop environment), 2 vCPUs, 2 GB RAM, and 16 GB of storage for the OS.
I mounted shared folders via NFS from the external drive by editing `/etc/fstab` on the VM:

```
192.168.142.14:/media  /mnt/storage/media nfs  defaults  0  0
```

The easiest way to deploy the applications is to use [`docker`](https://www.docker.com/) with [Docker Compose](https://docs.docker.com/compose/).
My project layout looks like this:

```
.
├── config
│   ├── lidarr
│   ├── navidrome
│   ├── prowlarr
│   ├── slskd
│   │   └── slskd.yml
│   └── soularr
│       └── config.ini
└── docker-compose.yml
```

The `docker-compose.yml` can look like this (paths/IDs adjusted to taste):

```yaml
services:
  lidarr:
    image: lscr.io/linuxserver/lidarr:latest
    container_name: lidarr
    hostname: lidarr
    user: 1000:1000
    environment:
      - PUID=1000
      - PGID=1000
    volumes:
      - /home/music/musicsh/config/lidarr:/config
      - /mnt/storage/media/music:/music
      - /mnt/storage/media:/data
      - /mnt/storage/media/downloads:/downloads
      - /mnt/storage/media/downloads_torrent:/downloads_torrent
    ports:
      - 8686:8686
    restart: unless-stopped

  slskd:
    image: slskd/slskd:latest
    container_name: slskd
    hostname: slskd
    user: 1000:1000
    volumes:
      - /home/music/musicsh/config/slskd:/app
      - /mnt/storage/media:/data
      - /mnt/storage/media/downloads:/downloads
      - /mnt/storage/media/downloads_incomplete:/downloads_incomplete
    environment:
      - PUID=1000
      - PGID=1000
      - SLSKD_UMASK=000
      - SLSKD_REMOTE_CONFIGURATION=true
    ports:
      - 5030:5030
      - 5031:5031
      - 50300:50300
    restart: unless-stopped

  soularr:
    image: mrusse08/soularr:latest
    container_name: soularr
    depends_on:
      - lidarr
      - slskd
    hostname: soularr
    user: 1000:1000
    environment:
      - PUID=1000
      - PGID=1000
      - SCRIPT_INTERVAL=300 # Script interval in seconds
    volumes:
      - /mnt/storage/media/downloads:/downloads
      - /home/music/musicsh/config/soularr:/data
    restart: unless-stopped

  prowlarr:
    image: lscr.io/linuxserver/prowlarr:latest
    container_name: prowlarr
    hostname: prowlarr
    user: 1000:1000
    environment:
      - PUID=1000
      - PGID=1000
    volumes:
      - /home/music/musicsh/config/prowlarr:/config
    ports:
      - 9696:9696
    restart: unless-stopped

  navidrome:
    image: deluan/navidrome:latest
    container_name: navidrome
    hostname: navidrome
    user: 1000:1000
    environment:
      - PUID=1000
      - PGID=1000
    volumes:
      - /home/music/musicsh/config/navidrome:/data
      - /mnt/storage/media/music:/music:ro # Read-only mount of the music library
    ports:
      - 8000:4533
    restart: unless-stopped
```

To start the containers run `docker compose up -d` which starts them in the background.

Configure `Lidarr` by creating a root folder (e.g. `/music`) in `Settings -> Media Management` and point it to `/mnt/storage/media/music` on the host.
On the `Download Clients` page add the `qBittorrent` client (IP, port, credentials). `qBittorrent` will fetch music from indexers provided by `Prowlarr`.

Before continuing, copy the `Lidarr` API key from `Settings -> General` for integrations.

![Lidarr configuration](/assets/img/homelab/lidarr-config.png)
_`Lidarr` configuration_

For `Prowlarr`, the configuration is quite simple.
We open its web interface, and first we need to add application that will use it as indexer.
In our case, that is `Lidarr`, so we add the IP address and port of `Lidarr` and we enter the `Lidar` API key.
Then, we just need to add indexers, by going on the `Indexers` page and pressing the `Add Indexer` button.
There is a big list of indexers that we can choose.
I've opted to use few famous torrent indexers.
After adding the indexers, they should appear in `Lidarr`, on `Settings -> Indexers` page.

![Prowlarr configuration](/assets/img/homelab/prowlarr-config.png)
_`Prowlarr` configuration_

As we already said, the Soulseek system is quite famous for sharing music files.
`slskd` is Soulseek client that we can use to download the shared music files, but `Lidarr` doesn't provide direct integration with it.
Instead, we are going to use the `Soularr` script that provides this connection.
Basically, `Soularr` will check the wanted music from `Lidarr` and tell `slskd` to try and find the wanted music files.
`slskd` will download the music files if it founds them and after they are downloaded, it will tell `Lidarr` that they are ready and `Lidarr` can import them in the music library.

`slskd` is [configured](https://github.com/slskd/slskd/blob/master/docs/config.md) with the `config/slskd/slskd.yml` file, by specifying username and password for Soulseek, providing API key that will be used to access `slskd` from `Soularr` and configuring the download directories.
The API key needs to be 32 characters (128-bits) long, and can be generated online, for example with [JWT Secret Key Generator](https://jwtsecrets.com/#generator).
Example configuration file follows.

```yaml
soulseek:
  username: slskdUser0012
  password: slskdPass0012

web:
  authentication:
    disabled: false
    username: slskd  # web UI
    password: slskd
    api_keys:
      soularr:
        key: 7ef64be003115694c28b8ccaac808d79
        role: administrator
directories:
  incomplete: /downloads_incomplete
  downloads: /downloads
```
{: file="config/slskd/slskd.yml"}

Finally, we need to configure `Soularr`, with the `config/soularr/config.ini` file.
We need to specify `Lidarr` and `slskd` API key, URL and download directory, and we can customize which music files to search for (i.e. only mp3 320 kbps), from which formats (CD, Vinyl, Digital, etc.) and few more options.
Check the `Soularr` [documentation](https://github.com/mrusse/soularr?tab=readme-ov-file#configure-your-config-file) for more info.

```ini
[Lidarr]
api_key = <LIDARR_API_KEY>
host_url = http://lidarr:8686
download_dir = /downloads

[Slskd]
api_key = 7ef64be003115694c28b8ccaac808d79  # matched with the slskd.yml config above
host_url = http://slskd:5030
url_base = /
download_dir = /downloads
delete_searches = False
stalled_timeout = 3600

[Release Settings]
use_most_common_tracknum = True
allow_multi_disc = True
accepted_countries = Europe,Japan,United Kingdom,United States,[Worldwide],Australia,Canada
skip_region_check = False
accepted_formats = CD,Digital Media,Vinyl

[Search Settings]
search_timeout = 5000
maximum_peer_queue = 50
minimum_peer_upload_speed = 0
minimum_filename_match_ratio = 0.8
allowed_filetypes = mp3 320,mp3
search_for_tracks = True
album_prepend_artist = False
track_prepend_artist = True
search_type = incrementing_page
number_of_albums_to_grab = 5
remove_wanted_on_failure = False
search_source = missing

[Logging]
level = INFO
# https://docs.python.org/3/library/logging.html#logrecord-attributes
format = [%(levelname)s|%(module)s|L%(lineno)d] %(asctime)s: %(message)s
# https://docs.python.org/3/library/time.html#time.strftime
datefmt = %Y-%m-%dT%H:%M:%S%z
```
{: file="config/soularr/config.ini"}

The last piece of the puzzle is `Navidrome`, that will serve the music library.
It provides web-based music player, but also subsonic API, so we can access the music library in many mobile phone applications.

![Navidrome and Symfonium](/assets/img/homelab/navidrome-symfonium.png)
_Navidrome and Symfonium_

## Conclusion

Creating a personal homelab is a fun and educational project.
You can learn a lot, and it doesn't take much money to get started.
An old PC or a single-board computer and a router are all you need to begin.
Over time you can upgrade hardware depending on your needs.
Besides the educational benefits, a homelab can be practical — from managing media files and blocking ads to hosting personal projects and applications.
I've shared tips and ideas from my homelab that I hope will inspire others to build their own.