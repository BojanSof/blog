---
title: Rise of the Homelab
date: 2025-06-20
categories: [Networking, Homelab]
tags: [networking, homelab, vm, containers, docker, proxmox]
math: false
image:
  path: /assets/img/homelab/cover.webp
---

Homelab is personal IT environment used for learning, experimenting and self-hosting services.
Personally, it allowed me to learn a lot of new things regarding networking, security, self-hosting applications and managing the whole environment.
In this blog post, I am going to describe my homelab, the process of creating it and some of the challenges I found during the development.
Currently, it is simple and not that complicated, but it can give some some insights to anyone wanting to start one!

## Brief history of my homelab

Earlier this year, I moved to new appartment.
While I was packing the boxes with stuff from the old appartment, I found old [FritzBox](https://fritz.com/en) all-in-one router and DSL modem in one of the storage shelves.
The specific model was [FritzBox 7360SL](https://boxmatrix.info/wiki/FRITZ!Box_Fon_WLAN_7360_SL).
To me such boxes like this are very fascinating because they are basically embedded Linux machines, which have potential to do a lot of other stuff beside their main purpose.
How cool it is to have VPN server to your home network running on the router itself!
Or blocking ads for the whole network!

I had experience with modding other FritzBox device - around 1 and a half year ago, I was trying to mod another FritzBox device to run [Freetz](https://freetz.github.io/)(the maintained fork of the project is [Freetz-NG](https://freetz-ng.github.io/freetz-ng/)) - firmware modifications for FritzBox which allows to run custom packages on the FritzBox, like VPN servers, HTTP servers, custom DNS, etc.
Also I'll use this opportunity to mention that there is a whole wiki page for FritzBox devices, [BoxMatrix](https://boxmatrix.info/wiki/BoxMatrix).
It contains a lot of technical details for many different FritzBox devices.
I had the fortune to colaborate with the maintainer of BoxMatrix, hippie2000, to get Freetz running on my FritzBox, from whom I learnt a lot of stuff regarding what it takes to mod and adapt linux configurations and modules.
Kudos to him!
I used this FritzBox device to run OpenVPN server to access the home network, and I was running [dnsmasq](https://en.wikipedia.org/wiki/Dnsmasq) with [Addhole](https://freetz-ng.github.io/freetz-ng/make/addhole/?h=addhole) extension, to block list of hostnames that contain ads, malwares, trackers and other unwanted things.
It also helped me learn about terms like [Dynamic DNS](https://en.wikipedia.org/wiki/Dynamic_DNS) and [DMZ](https://en.wikipedia.org/wiki/DMZ_(computing)), and see how to practically use them.
But it wasn't the smoothest experience, as the hardware was a bit outdated and didn't have a lot of power.

Now going back to packing the FritzBox 7360SL, I made a quick google search on it, and I've noticed that [OpenWRT](https://openwrt.org/) supports this device.
I always wanted to try OpenWRT, Linux targetting embedded devices, mainly handling networking tasks.
It is a great way to keep old equipment, unsupported by the manufacturer anymore, running with the latest Linux kernel version, security patches and bug fixes.
OpenWRT also has very big comprehensive package list.

After moving to the new appartment, I had some time and started playing with the FritzBox 7360SL.
I installed OpenWRT on it following [OpenWRT guide](https://openwrt.org/toh/avm/fritz.box.wlan.7360), I was amazed how many confiugrations and customizations were available in the Web UI, making the hardware feel so powerful.
Creating network interfaces, creating VLANs, managing firewall zones, looking at the enormous OpenWRT package list were things that opened the doors to many new learning opportunities.

Quickly after that, I got introduced to [Proxmox](https://pve.proxmox.com/wiki/Main_Page) - server virtualization management solution based on QEMU/KVM and LXC (Linux Containers).
I bought myself cheap refurbished HP260 G2 mini PC, with i3-6100U 2-core/4-thread CPU, 8 GB RAM and 256 GB SSD.
It has a very small form-factor, making it easy to put it under table or in a corner.
I've installed Proxmox on it and started spinning out VMs and LXCs - Adguard Home for DNS, InfluxDB and Grafana for monitoring the PC, Nginx Reverse Proxy, host my WebRTC chat application, self-host Music library, and many more.

My latest update to the homelab equipment was [GL.iNet Flint 2](https://www.gl-inet.com/products/gl-mt6000/), a high-performance router, which I got as gift for my birthday.
The Flint 2 is considered one of the best OpenWRT routers from many users - it has very power CPU (MediaTek Filogic 830, MT7986AV), 1 GB RAM and 8 GB eMMC, two 2.5 Gbit ports and four 1 Gbit ports, and USB 3.1 port.
It upgraded the FritzBox 7360SL device, which was behaving weirdly sometimes - WiFi was disconnecting and it was becoming unresponsive.
Now, the whole networks feels much smoother.

## Diagram

![Homelab diagram](/assets/img/homelab/homelab.svg){: .light}
![Homelab diagram](/assets/img/homelab/homelab-dark.svg){: .dark}
_Diagram of my current homelab_

The homelab is pretty simple.
The Flint 2 is connected to the ISP gateway.
The ISP gateway is NOT configured in bridge mode, as I need to contact the ISP to configure the gateway in bridge mode.
The HP 260 G2 is the server running proxmox and all containers and VMs.
Before I had the Flint 2, the FritzBox 7360SL was doing its job.

> One thing that I found useful with the FritzBox 7360SL, which has small amount of internal Flash memory, is to use small external USB drive to extend the root file system, to have storage for installing packages. OpenWRT wiki has [tutorial](https://openwrt.org/docs/guide-user/additional-software/extroot_configuration) how to achieve this.
{: .prompt-info }

### Router config

The Flint 2 router by default runs GL.iNet firmware, which is a fork of the official OpenWRT project, aiming to provide ease of use, by limitting some of the features that stock OpenWRT provides.
Also the manufacturer can delay or stop delivering updates and features, while OpenWRT will be updated and maintained beyond that moment.
For these reasons, I've installed stock OpenWRT on the Flint 2, following the [OpenWRT wiki](https://openwrt.org/toh/gl.inet/gl-mt6000), which is a very easy process, as the original firmware is OpenWRT basically.

#### LuCI theme

After installing the stock OpenWRT, I liked to change the OpenWRT web interface (called LuCI) theme.
OpenWRT wiki has overview for [LuCI themes](https://openwrt.org/docs/guide-user/luci/luci.themes).
The theme that I like to use is called [Argon](https://github.com/jerrykuku/luci-theme-argon).
This theme provides both dark and light modes, and one can customize the accent colors, the login background and few more options.
The [theme's github repo](https://github.com/jerrykuku/luci-theme-argon) provides instructions how to install the theme.

![LuCI with Argon theme](/assets/img/homelab/luci-argon.png)
_LuCI (OpenWRT web interface) with Argon theme_

#### Wake-on-LAN (WoL)

Rarely, it happens to be power outage.
After power is restored, the router automatically turns on, but the computers usually don't.
This means that all the services hosted on the computers that are part of the homelab won't be available, until you manually power them on.

To resolve this issue, the computer network interface card (NIC) can listen to incoming network traffic even when the computer is OFF.
When a specific frame is sent on the network, called magic packet, containing the MAC address of the NIC, the NIC can power-on the computer, same effect as manually pressing the power-on button.
This feature is called [Wake-on-LAN (WoL)](https://en.wikipedia.org/wiki/Wake-on-LAN).

We can make the router send magic packet to a computer, to power it on.
To make WoL work properly, we need to configure both the router and the computer that needs to be awaken.
In this section, we will only configure the router, while the computer part will be presented later.

OpenWRT wiki has [page](https://openwrt.org/docs/guide-user/services/w_o_l/wol) for configuring WoL.
On the Flint 2, to use the WoL feature we need to install package called `etherwake`, which is a command-line utility that can generate and send magic packet.
Beside `etherwake`, there is also package called `luci-app-wol`, which basically adds option to utilize the WoL feature via the router web interface, under `Services -> Wake on LAN` page.
`luci-app-wol` will also install `etherwake` as its dependency.
Installing packages on OpenWRT is quite easy and can be done via LuCI, by going to `System -> Software`, then `Update lists...` to update the packages list and search and install the `luci-app-wol` package.
The installation can also be done via command line after connecting to the router via SSH, by issuing `opkg update && opkg install luci-app-wol`.

If we want to wake computer or any device that supports WoL automatically when the router boots, we can add `etherwake` command in `/etc/rc.local`:
```
# wake the computer with MAC aa:bb:cc:dd:ee:ff, connected on `br-lan` network interface
etherwake -i br-lan -b aa:bb:cc:dd:ee:ff

exit 0
```
{: file='/etc/rc.local'}

#### WireGuard VPN server

Often, we require access to our homelab network from outside.
To achieve this, we can use [VPN](https://en.wikipedia.org/wiki/Virtual_private_network).
In my scenario, I run WireGuard VPN server on the Flint 2 and use WireGuard client on my laptop and phone to access the homelab network when needed.

Before configuring the WireGuard server, we need to know the public IP address for our network.
There are multiple options for the public IP address:
1. The user has static IP, i.e. the address `92.56.292.123` always belonds to the user and never changes. This is the simplest scenario, but often ISP require users to pay additional money for this.
2. The user has dynamic IP address, which means his IP may change depending on some policy, i.e. after few hours or days. In this scenario the user can use [Dynamic DNS (DynDNS)](https://en.wikipedia.org/wiki/Dynamic_DNS) service, which basically updates given domain DNS record whenever the IP changes. There are many free DynDNS services that can be used. I use [`No-IP`](https://www.noip.com/), which provide DynDNS service for free, for single domain. After registering for DynDNS service, one needs to enter the domain and the security info for the domain on the router. Currently, I do that on the ISP gateway.
3. It is possible that the user public IP address is shared with multiple other users, by utilizing [CGNAT technology](https://en.wikipedia.org/wiki/Carrier-grade_NAT). This is the most tricky scenario, as the IP address is shared and I am not familiar with solutions for this scenario.

The OpenWRT wiki has [tutorial](https://openwrt.org/docs/guide-user/services/vpn/wireguard/server) for configuring WireGuard VPN server, both via command-line and via LuCI.
The process is straight forward:
1. Install the required package, `luci-proto-wireguard` should install everything that is required
2. Create new network interface with the `WireGuard VPN` protocol, named `wg0` for example
3. Press on the `Edit` button for the network interface and in the `General` tab press on `Generate new key pair` to generate the server public and private keys.
4. Enter the IP address for the VPN and the UDP listen port.
5. Ensure to assign firewall zone for this network interface. It can be the `lan` zone, used for the other devices that are part of the network.
6. Save all the changes.

After the server is configured, we can add peers, which is quite simple using the web interface:
1. Press on `Edit` on the WireGuard network interface, then go to the `Peers` tab.
2. Press on `Add peer` button
3. Generate the public/private key combo for the client
4. Add IPv4 address in the `Allowed IPs` field, on the same subnet as the one specified during server configuration.
5. Set the `Endpoint host` to the domain where your static IP is bound, or the DDNS domain.
6. Set `Persistent Keep Alive` to 25.
7. Save the peer configuration.
7. Then go and press `Edit` again and click on the `Generate Configuration...` button, to generate the config for the WireGuard client.

Sample WireGuard client config should look like this:
```
[Interface]
PrivateKey = GEKQHqEBBnCJXsFDVwKSZCy9VxV/OEBVUkLlISxBvVM=
Address = 10.10.0.10/32
DNS = 192.168.1.1

[Peer]
PublicKey = EjmgJpwmXgOWyaj3+ndUbbtRKs7FCn86xKpifzKOZj4=
PresharedKey = G3j9waP+Er04RVlSSk5MJgyNIwEW6z+Qybku8x4+eak=
AllowedIPs = 0.0.0.0/0, ::/0
Endpoint = example.domain.net:51820
PersistentKeepalive = 25
```
{: file='wg-client.conf'}

WireGuard provides [client softwares](https://www.wireguard.com/install/) for many operating systems.
Install and apply the peer configuration that we generated.
For easy testing on PC/Laptop for example, enable hotspot on your mobile phone to share the mobile data, connect to the hotspot, activate the WireGuard tunnel and check if you can access the homelab network.

Finally, we need to configure the firewall to forward the WireGuard port.
This can be done via LuCI, by going to `Network -> Firewall` then `Port Forwards`.
Add new port forwarding rule, set the source to the WAN interface, external port to the WireGuard port, i.e. 51820 by default, set the destination zone to the WireGuard interface assigned firewall zone and set the internal port, often same as the external one.

With this, we can easily access our homelab network from anywhere!

> If you have another router in front of the one running the WireGuard server, you also need to do the port forwarding configuration on it. Another alternative is to enable [DMZ host (demilitarized zone)](https://en.wikipedia.org/wiki/DMZ_(computing)#DMZ_host) feature on the front router, which makes its firewall expose all ports to the DMZ host, which in our case is the router running WireGuard server.
{: .prompt-info }

### Proxmox server

![Proxmox web interface](/assets/img/homelab/proxmox.png)
_Proxmox web interface_

When I started playing with firmware extensions and modifications for routers, which had low amount of Flash and RAM, it felt so powerful to be able to run additional software on it, like custom DNS with ad blocking.
However, I quickly realized their limits.
At that time, I got introduced to Proxmox, open-source virtualization platform that basically would allow me to self-host variety of applications.
So, I bought myself refurbished HP 260 G2, mini PC just for this purpose.
It has Intel i3-6100U CPU with 2 cores/4 threads, 8 GB of RAM and 256 GB of SSD.
Additionally, I had 512 GB NVME SSD, put inside external USB enclosure and connected to the PC, useful for storing many kinds of files.

Installing Proxmox is quite easy and similar like any other OS.
Proxmox also has wiki pages, which have a ton of technical details and tutorials, including [installation](https://pve.proxmox.com/wiki/Installation) page.
But there are also a ton of online resources in case one gets stuck on something.
Before installing proxmox, ensure to enable virtualization in the PC BIOS/UEFI, most commonly called `Virtualization Technology`.

After installing proxmox, it provides web interface accessible on the IP assigned to the PC.

#### Enabling WoL

Before carrying on with spinning up containers and VMs, let's enable Wake-on-LAN on the proxmox server, so the router can power it on using magic packet.

1. Enable the WoL feature in the BIOS/UEFI
2. Boot the PC and open the proxmox shell
3. Install the `ethtool` package: `apt install ethtool`
4. Edit the `/etc/network/interfaces` file, and under the ethernet interface used for connecting to the router add the line `post-up /usr/sbin/ethtool -s enp1s0 wol g`, which enables the WoL on magic packet after the network interfaces comes up:

```
auto lo
iface lo inet loopback

iface enp1s0 inet manual
post-up /usr/sbin/ethtool -s enp1s0 wol g

auto vmbr0
iface vmbr0 inet static
        address 192.168.1.2/24
        gateway 192.168.1.1
        bridge-ports enp1s0
        bridge-stp off
        bridge-fd 0

source /etc/network/interfaces.d/*
```
{: file='/etc/network/interfaces'}

#### Proxmox VE Helper-Scripts

Before going over some of the self-hosted applications I have, I wanted to mention one great community project, called [Proxmox VE Helper-Scripts](https://community-scripts.github.io/ProxmoxVE/).
The goal of this community project is to provide scripts to simplify the setup and management of services on the Proxmox server.
It provides great collection of scripts that one can use to install many different applications, including network-related services, web servers, media hosting solutions and many more.
Before trying to install something manually, by spinning VM or LXC, be sure to check the helper scripts, they can save a lot of time!

#### AdGuard Home

![AdGuard Home Dashboard](/assets/img/homelab/adguard-home.png)
_AdGuard Home Dashboard_

One most common service found in homelab is ad-blocking one.
The solution I opted for was to use [AdGuard Home](https://github.com/AdguardTeam/AdGuardHome), which is free, open-source, network-wide ads tracker and blocker DNS server.
I installed it using [helper script](https://community-scripts.github.io/ProxmoxVE/scripts?id=adguard), which creates LXC for it.

Basically, AdGuard Home is DNS server, which provides option to add blocklists of hosts, which won't be allowed on the network.
First, one needs to configure the upstream DNS server to use, by going to `Settings -> DNS settings` and enterring the IP address of the chosen DNS server in the `Upstream DNS servers` textbox.
There are few popular options for it that I want to mention:
- Google Public DNS: 8.8.8.8 and 8.8.4.4, which provides fast performance and very good reliability.
- Cloudflare DNS: 1.1.1.1 and 1.0.0.1, focusing on privacy.
- Quad9  DNS: 9.9.9.9, focusing on security by blocking malicious websites, ensuring safer browsing.

Additionally, if you want to ensure that only devices on your network can use AdGuard Home DNS, you can go to `Settings -> DNS settings`, and under the `Access settings` pane, enter the CIDRs in the `Allowed clients` text box.

![AdGuard Home DNS configuration](/assets/img/homelab/adguard-home-dns-cfg.png)
_AdGuard Home DNS configuration_

AdGuard Home provides quite few blocklists which one can select from.
Personally, I use [HaGeZi Pro](https://github.com/hagezi/dns-blocklists?tab=readme-ov-file#pro) and [HaGeZi TIF](https://github.com/hagezi/dns-blocklists?tab=readme-ov-file#tif) blocklists.
Another good source for blocklists that is worth mentioning is [firebog.net](https://firebog.net/).

After configuring AdGuard Home, we can change the DHCP server settings in our router, to provide the AdGuard Home IP address as DNS server, or we can can configure the DNS server IP on each client separately (we also must do this in case client uses static IP).

#### Nginx Proxy Manager

![Nginx Proxy Manager](/assets/img/homelab/nginx-proxy-manager.png)
_Nginx Proxy Manager Proxy Hosts page_

Before adding more applications and services to our homelab, there is one potential problem that would arise - remembering the IP addresses and ports of each application.
If there are 2-3 applications we may be able to remember their IPs and ports, to access their web interfaces, but then we start to forget and mix them.
We can always check their IPs in proxmox, but we can create a better solution using [Nginx Proxy Manager](https://nginxproxymanager.com/).

Nginx Proxy Manager is an open-source tool that provides user-friendly web interface for configuring reverse proxies, without needing to write configuration files for [Nginx](https://nginx.org/).
Basically, its purpose is to forward domain requests (i.e. example.com) to correct internal server (i.e. server that has IP `192.168.1.45:4000`).
Instead of remembering IP addresses for our applications and services, we can use domains, like `adguardhome.local`.
The more complicated explanation for what Nginx Proxy Manager does is that it utilizes Nginx as reverse proxy, easy and automated SSL certificates from [Let's Encrypt](https://letsencrypt.org/) and provides simple, user-friendly web interface.

We can install it in LXC, using [helper script](https://community-scripts.github.io/ProxmoxVE/scripts?id=nginxproxymanager).
After installing Nginx Proxy Manager, we need to tell the manager how to redirect the domains, to which IP addresses.
We can simply do this by going to `Hosts -> Proxy Hosts` page.

![Adding proxy host in Nginx Proxy Manager](/assets/img/homelab/nginx-add-host.png){: w="400"}
_Adding proxy host in Nginx Proxy Manager for AdGuard Home_

Finally, we need to tell our DNS server to redirect the requests for the `.local` domains to the Nginx Proxy Manager instance.
In Adguard Home, we can do this by going to `Filters -> Custom filtering rules` page and add the rules in format `<Nginx Proxy Manager IP> example.local`, i.e. if the Nginx Proxy Manager IP is `192.168.1.4`, we can add the following rule `192.168.1.4 adguardhome.local`.

As a bonus, Nginx Proxy Manager doesn't have dark mode support, but we can easily add one following the [GitHub issue](https://github.com/NginxProxyManager/nginx-proxy-manager/issues/707) related to this topic.
Basically, we add proxy host for Nginx itself, let's say `nginx.local`, and under `Custom Locations` we add the following settings, copied from the GitHub issue:
```
proxy_set_header Accept-Encoding "";
sub_filter
   '</head>'
   '<link rel="stylesheet" type="text/css" href="https://theme-park.dev/css/base/nginx-proxy-manager/organizr.css">
   </head>';
sub_filter_once on;
```
{: file='nginx_theme'}

![Nginx Proxy Manager dark mode](/assets/img/homelab/nginx-dark-mode.png)
_Adding theme support for Nginx Proxy Manager_

#### Open Media Vault

![Open Media Vault dashboard](/assets/img/homelab/omv.png)
_Open Media Vault dashboard_

I had one 512 GB NVME SSD laying around, so I thought I can use it for media storage.
I bought USB M.2 NVME SSD enclosure and connected the drive to the proxmox server.
Initially, what I did is I mounted the SSD on the proxmox server itself, and I used [Network File System](https://docs.kernel.org/filesystems/nfs/index.html) to share the SSD to the VM running the music library management.
The proxmox was running NFS server, while the VM was running NFS client.
Quickly after that, I wanted to also run Samba server, to access misc files on my network - and basically it was job of the proxmox server to manage the disk and the shares.
In that moment I realized that I made slight conceptual mistake - proxmox shouldn't be responsible for this, it should only manage the LXCs and VMs!

While searching for solutions to manage storage, I stumbled upon [Open Media Vault (OMV)](https://www.openmediavault.org/), which is NAS solution based on Debian, containing a lot of services, like SMB, NFS and FTP.
It seemed like a perfect solution to manage the drive, so I started migrating my old solution, in which proxmox was managing the drive, to the new solution, on which OMV will manage the drive and create all the required shares.

I installed OMV inside VM, and passthrough the external drive to the VM, following the Proxmox [wiki page tutorial](https://pve.proxmox.com/wiki/Passthrough_Physical_Disk_to_Virtual_Machine_(VM)):
```
# First find the UUID of the drive
lsblk -o PATH,TYPE,MOUNTPOINT,UUID
# Passthrough the drive
qm set <OMV_VM_ID> -scsi1 /dev/disk/by-uuid/<DISK-UUID>
```
{: file='vm_drive_passthrough'}

Now, we can configure OMV to manage the drive.
As I had existing file-system on my drive, I've mounted it by going to `Storage -> File Systems` and pressing the `Mount an existing file system` button, then selecting the external drive file system.

After the filesystem is configured, we can start utilizing services, like NFS and SMB to share the drive.
Before doing so, OMV requires as to to create [shared folder](https://docs.openmediavault.org/en/latest/administration/storage/sharedfolders.html), by going to `Storage -> Shared Folders`.
For each shared folder, we specify the file system that we want to use and the relative path from the root.
Remeber that each service we are going to use later, we must bound it to single shared folder.
In my case, I have share folder for the media library (which currently consists only of music), share folder for Samba, and I have one share folder for the whole external drive (which may not be a good practice), which is used for the NFS share on the proxmox server itself, to provide access to the external drive to LXCs that need it.

One thing that I won't cover here is permissions of the folders and how to handle them in best manner.
Instead, what I did is I owned the whole external drive partition by the OMV VM, by running `chmod -R 777 /srv/dev-disk-by-uuid-XXXX`, then for the NFS shares for the music VM, I've added options `all_squash, anongid=1001, anonuid=1001`, which means every request, from no matter which user on the NFS client, treat is as it comes from the anonymous user, and use UID and GID of 1001.

As I've already mentioned, one of the NFS shares is used to provide access to the external drive to LXCs.
To make this work, the proxmox server acts as NFS client and mounts the share by adding the following line in `/etc/fstab`:
```
# ...
# OTHER CONTENT of the file
# ...
192.168.142.14:/storage /mnt/storage nfs defaults,_netdev,nofail,x-systemd.automount,x-systemd.mount-timeout=30 0 0
```
{: file='/etc/fstab'}

Note the options for the mount, `_netdev,nofail,x-systemd.automount,x-systemd.mount-timeout=30`, which specify that the mount is network device (`_netdev`), not to fail the boot process if the mount is not successfult on boot (`nofai`) and tells `systemd` to mount the share when something, like LXC, tries to access the mount directory, with a given timeout (`x-systemd.automount,x-systemd.mount-timeout=30`).

Briefly, to use Samba, which enables file sharing across different operating systems over a network, first we need to create users in OMV and then create SMB share.
Then we can access the Samba share on other system on the network using the credentials of the user we created.

#### Self-hosted Music Library

One of the best things to do in a homelab is to self-host media services - music, movies, TV series, books, etc.
There is a collection of programs, referred to as [*Arrs](https://wiki.servarr.com/), which can automatically download and organize ones media collections.
The most commonly used of this suite of programs are:
- [Lidarr](https://lidarr.audio/), music collection manager,
- [Sonarr](https://sonarr.tv/), TV series collection manager,
- [Radarr](https://radarr.video/), movies collection manager,
- [Prowlarr](https://prowlarr.com/), which is indexer manager for the other *Arrs.

We are going to use `Lidarr` for managing hte music library.
For managing indexers and downloading music, we are going to utilize `Prowlarr`, which will manage torrent indexers and [`Soularr`](https://soularr.net/), which is a script that connects `Lidarr` with [`Soulseek`](https://www.slsknet.org/news/), using the [`slskd`](https://github.com/slskd/slskd) client.
`Soulseek` is peer-to-peer file-sharing application, primarily used by music lovers to share and download digital content.
It is similar to torrent, with the difference being that `Soulseek` uses singular connection, to one seeder, as opposed to torrenting, which can pull parts of the file from one or more seeders.
We are also going to use [`qBitTorrent`](https://www.qbittorrent.org/) as torrent client.
As a streaming service, we will use [`Navidrome`](https://www.navidrome.org/), which also provides web UI for listening the music library, but it is also compatible with the [Subsonic API](https://www.subsonic.org/pages/api.jsp), which is supported by many applications.
On Android, I personally like [`Symfonium`](https://symfonium.app/) music player app, which is not a free app and requires one-time payment for life-time, providing very good design and also has chromecast support, to cast music directly on Google TV.
There are free applications available, like [`substreamer`](https://substreamerapp.com/), but I prefer `Symfonium` over it.

So to summarize, we have the following list of applications that will consist our self-hosted music library solution: `Lidarr`, `Prowlarr`, `Soularr`, `slskd`, `Navidrome` and `qBitTorrent`.
We will deploy all of them on a single VM, except for `qBitTorrent` client, which we will deploy as LXC and we can use it for other purposes too.

I've created VM with [Debian 13](https://www.debian.org/News/2025/20250809), without DE, with 2 vCPUs, 2 GB RAM and 16 GB of storage for the OS.
The easiest way to deplot the applications is using [`docker`](https://www.docker.com/).
We are going to use [Docker Compose](https://docs.docker.com/compose/) for running the multiple containers - one for each app.
```
```
{: file='docker-compose.yml'}
TUTORIAL HOW TO CONNECT THE DIFFERENT APPLICATIONS (THEIR CONFIG FILES)

I've put the required configuration files on [GitHub](https://github.com/BojanSof/self-host-music), along with a readme file, to know what to change in them.

#### Self-hosting Web Application

## Conclusion